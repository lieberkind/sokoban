<html>
<head>
    <meta charset="UTF-8">
    <title>Document</title>

    <style>
        * { margin: 0; padding: 0; }
        canvas { 
            background: cyan;
            width: 304px;
            height: 272px;
        }
    </style>
</head>
<body>
    <canvas id="game"></canvas>
    <script>
        var DIRECTIONS = {
            up: 'up',
            right: 'right',
            down: 'down',
            left: 'left',
            none: 'none'
        };

        var level1 = {
            grid: [
                "###################",
                "###################",
                "###################",
                "#####...###########",
                "#####...###########",
                "#####...###########",
                "###......##########",
                "###.#.##.##########",
                "#...#.##.#####..xx#",
                "#...............xx#",
                "#####.###.#.##..xx#",
                "#####.....#########",
                "###################",
                "###################",
                "###################",
                "###################",
                "###################",
            ],
            crates: [
                { x: 5, y: 4},
                { x: 7, y: 5},
                { x: 7, y: 6},
                { x: 5, y: 6},
                { x: 5, y: 9},
                { x: 2, y: 9},
            ],
            player: { x: 11, y: 10 }
        }

        function getNextPosition(currentPosition, direction) {
            switch (direction) {
                case DIRECTIONS.up: return { x: currentPosition.x, y: currentPosition.y - 1};
                case DIRECTIONS.right: return { x: currentPosition.x + 1, y: currentPosition.y};
                case DIRECTIONS.down: return { x: currentPosition.x, y: currentPosition.y + 1};
                case DIRECTIONS.left: return { x: currentPosition.x - 1, y: currentPosition.y};
                default: return { x: currentPosition.x, y: currentPosition.y };
            }
        }

        function isSamePosition(pos1, pos2) {
            return pos1.x === pos2.x && pos1.y === pos2.y;
        }

        function Level(level) {
            this.grid = level.grid.map(function(row) {
                return row.split("");
            });
            this.crates = level.crates;
            this.player = level.player;
        }

        Level.prototype.isBlock = function(position) {
            return this.grid[position.y][position.x] === '#';
        };

        Level.prototype.isWithinMaze = function(position) {
            return position.x < this.grid[position.y].length &&
                position.x >= 0 &&
                position.y < this.grid.length &&
                position.y >= 0 &&
                !this.isBlock(position);
        };

        function Player(game, initPosX, initPosY) {
            this.game = game;
            this.position = {
                x: initPosX,
                y: initPosY
            }
        }

        Player.prototype.canMove = function(direction) {
            var dPosition = getNextPosition(this.position, direction);

            var crates = this.game.gameObjects.filter(function(gameObject) {
                return gameObject.constructor === Crate;
            });

            var canMoveCrate = crates.reduce(function(canMoveCrate, crate) {
                if(isSamePosition(crate.position, dPosition)) {
                    return canMoveCrate && crate.canMove(direction);
                }
                return canMoveCrate;
            }, true);

            return this.game.getCurrentLevel().isWithinMaze(dPosition) && canMoveCrate;
        };

        Player.prototype.move = function(direction) {
            var self = this;

            this.position = getNextPosition(this.position, direction);

            var crates = this.game.gameObjects.filter(function(gameObject) {
                return gameObject.constructor === Crate;
            });

            crates.forEach(function(crate) {
                if(isSamePosition(self.position, crate.position)) {
                    crate.move(direction);
                }
            });
        };

        Player.prototype.draw = function() {
            var ctx = this.game.ctx;
            ctx.beginPath();
            ctx.rect(this.position.x * 16, this.position.y * 16, 16, 16);
            ctx.fillStyle = '#F00';
            ctx.fill();
            ctx.closePath();
        };

        Player.prototype.update = function() {
            var direction;

            direction = this.game.getPressedDirection();

            if(this.canMove(direction)) {
                this.move(direction);
            };
        }

        function Block(game, posX, posY) {
            this.game = game;
            this.position = {
                x: posX,
                y: posY
            };
        }

        Block.prototype.draw = function() {
            this.game.ctx.beginPath();
            this.game.ctx.rect(this.position.x * 16, this.position.y * 16, 16, 16);
            this.game.ctx.fillStyle = '#CCC';
            this.game.ctx.fill();
            this.game.ctx.closePath();
        };

        Block.prototype.update = function() {};

        function Crate(game, posX, posY) {
            this.game = game;
            this.position = {
                x: posX,
                y: posY
            };
        };

        Crate.prototype.canMove = function(direction) {
            var dPosition = getNextPosition(this.position, direction);

            var crates = this.game.gameObjects.filter(function(gameObject) {
                return gameObject.constructor === Crate;
            });

            var crateIsBlocking = false;

            crates.forEach(function(crate) {
                if(crate.position.x === dPosition.x && crate.position.y === dPosition.y) {
                    crateIsBlocking = true;
                }
            });

            return this.game.getCurrentLevel().isWithinMaze(dPosition) && !crateIsBlocking;
        };

        Crate.prototype.move = function(direction) {
            this.position = getNextPosition(this.position, direction);
        };

        Crate.prototype.update = function() {};

        Crate.prototype.draw = function() {
            this.game.ctx.beginPath();
            this.game.ctx.rect(this.position.x * 16, this.position.y * 16, 16, 16);
            this.game.ctx.fillStyle = '#FF0';
            this.game.ctx.fill();
            this.game.ctx.closePath();
        };

        function Game(ctx) {
            this.ctx = ctx;
            this.gameObjects = [];
            this.pressedDirection = DIRECTIONS.none;
        }

        Game.prototype.draw = function() {
            this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
            this.gameObjects.forEach(function(gameObject) {
                gameObject.draw();
            });
        };

        Game.prototype.update = function() {
            this.gameObjects.forEach(function(gameObject) {
                gameObject.update();
            });
            this.resetInputs();
        };

        Game.prototype.resetInputs = function() {
            this.pressedDirection = DIRECTIONS.none;
        };

        Game.prototype.getPressedDirection = function() {
            return this.pressedDirection;
        };

        Game.prototype.setPressedDirection = function(direction) {
            this.pressedDirection = direction;
        };

        Game.prototype.loadLevel = function(level) {
            var self = this;
            this.level = level;

            level.grid.forEach(function(row, rowIdx) {
                row.forEach(function(field, fieldIdx) {
                    if(level.isBlock({x: fieldIdx, y: rowIdx})) {
                        self.addGameObject(new Block(self, fieldIdx, rowIdx));                        
                    }
                });
            });

            level.crates.forEach(function(cratePosition) {
                self.addGameObject(new Crate(self, cratePosition.x, cratePosition.y));
            });

            this.addGameObject(new Player(this, level.player.x, level.player.y));
        }

        Game.prototype.getCurrentLevel = function() {
            if(!this.level) {
                throw new Error('No level loaded.');
            }

            return this.level;
        };

        Game.prototype.addGameObject = function(obj) {
            this.gameObjects.push(obj);
        };

        var canvas = document.getElementById('game');
        canvas.width = 304;
        canvas.height = 272;

        var game = new Game(canvas.getContext('2d'));
        game.loadLevel(new Level(level1));

        addEventListener('keydown', function(e) {
            switch (e.keyCode) {
                case 37:
                    game.setPressedDirection(DIRECTIONS.left);
                    break;
                case 38:
                    game.setPressedDirection(DIRECTIONS.up);
                    break;
                case 39:
                    game.setPressedDirection(DIRECTIONS.right);
                    break;
                case 40:
                    game.setPressedDirection(DIRECTIONS.down);
                    break;
                default:
                    game.setPressedDirection(DIRECTIONS.none);
                    break;
            }

            game.update();
            game.draw();
        });

        game.update();
        game.draw();
    </script>
</body>
</html>
